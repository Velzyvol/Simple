go.property("player_type", hash("p1"))

local pc = require("game.player.player_config")
local GMASS=150
local GRAVITY = vmath.vector3(0,-GMASS,0)
local MAX_POWER_JUMP = 300000
local MIN_POWER_JUMP = 12000

local msg_contact_point_response = hash("contact_point_response")
local group_obstacle = hash("platform")
--Тут максимальная скорость, а то обьект может разогнатся до большой скорости и выйти за пределы доступных значений.
local max_speed = 100
--Блокировка падения.


local max_angle_arrow=math.pi/10
local speed_arrow=math.pi/180

function init(self)
	--Угол стрелы
	self.angle_arrow=0
	self.velocity = vmath.vector3(0,0,0)
	self.input = pc.input[self.player_type]
	self.correction = vmath.vector3()
	self.inc_jump_strength = false
	self.jump_strength = 0

	msg.post(".", "acquire_input_focus")
	msg.post("arrow", "input_set", { left = self.input.left, right = self.input.right })

	go.set_parent(go.get_id("arrow"), go.get_id("player"), true)
	msg.post("arrow", "update_angle", {angle_arrow=self.angle_arrow-math.pi/2})
end


function move_parabol_x(x0,v0,t)
	return x0+v0*t
end

function move_parabol_y(y0,v0,t)
	return y0+v0*t-0.5*GMASS*t*t
end

function sleepvel(len)
	return -math.exp(-len)+1
end

function fixed_update(self, dt)
	if self.inc_jump_strength then
		self.jump_strength = self.jump_strength + dt
		self.jump_strength = math.min(self.jump_strength, 1)
	end
	self.inc_jump_strength = false
	pc.position[self.player_type] = go.get_position()
end

function on_input(self, action_id, action)
	if action_id == self.input.left or action_id == self.input.right then
		--Здесь выбираем направление стрелочки
		if action_id == self.input.left then
			self.angle_arrow = self.angle_arrow - speed_arrow
		elseif action_id == self.input.right then
			self.angle_arrow = self.angle_arrow + speed_arrow
		end

		if self.angle_arrow > max_angle_arrow then
			self.angle_arrow=max_angle_arrow
		elseif self.angle_arrow < -max_angle_arrow then
			self.angle_arrow=-max_angle_arrow
		end

		--TODO TODO тут тебе смска
		msg.post("arrow", "update_angle", {angle_arrow=self.angle_arrow-math.pi/2,power_jump=self.power_jump})
	end

	if action_id == self.input.up then
		if not (action.pressed and action.released) then
			self.inc_jump_strength = true
		end
		if action.released then
			local effective_jump_power = math.clamp(self.jump_strength*MAX_POWER_JUMP, MIN_POWER_JUMP, MAX_POWER_JUMP)
			local angle = -(self.angle_arrow-math.pi/2)
			local jump_vec = vmath.vector3(math.cos(angle)*effective_jump_power, math.sin(angle)*effective_jump_power,0)
			print(jump_vec)
			msg.post("#collisionobject", "apply_force", {force = jump_vec, position = go.get_world_position()})
			self.is_on_platform = false

			self.inc_jump_strength = false
			self.jump_strength = 0
		end
	end
end
--значит движок уже просчитывает столкновение обьектов и передаёт это как сообщения в вин апи?
function on_message(self, message_id, message, sender)
	-- check if we received a contact point message
	if message_id == msg_contact_point_response then
		-- check that the object is something we consider an obstacle
		if message.group == group_obstacle then
			handle_obstacle_contact(self, message.normal, message.distance,message.other_id)
		end
	end

end

function handle_obstacle_contact(self, normal, distance, contactobj)
end